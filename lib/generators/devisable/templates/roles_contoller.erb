class RolesController < ApplicationController
  before_filter :accessible_permissions, :only => [:new, :edit, :show, :update, :create]
  load_and_authorize_resource
  
  # GET /roles
  # GET /roles.xml
  def index
    @roles = Role.all

    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml => @roles }
    end
  end

  # GET /roles/1
  # GET /roles/1.xml
  def show
    @role = Role.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.xml  { render :xml => @role }
    end
  end

  # GET /roles/new
  # GET /roles/new.xml
  def new
    @role = Role.new

    respond_to do |format|
      format.html # new.html.erb
      format.xml  { render :xml => @role }
    end
  end

  # GET /roles/1/edit
  def edit
    @role = Role.find(params[:id])
  end

  # POST /roles
  # POST /roles.xml
  def create
    @role = Role.new(params[:role])

    respond_to do |format|
      if @role.save
        @role.save_permissions(params[:role_ids])
        format.html { redirect_to(@role, :notice => 'The role has been created.') }
        format.xml  { render :xml => @role, :status => :created, :location => @role }
      else
        format.html { render :action => "new" }
        format.xml  { render :xml => @role.errors, :status => :unprocessable_entity }
      end
    end
  end

  # PUT /roles/1
  # PUT /roles/1.xml
  def update
    @role = Role.find(params[:id])

    respond_to do |format|
      if @role.update_attributes(params[:role])
        @role.save_permissions(params[:role_ids])
        format.html { redirect_to(@role, :notice => 'The role has been updated.') }
        format.xml  { head :ok }
      else
        format.html { render :action => "edit" }
        format.xml  { render :xml => @role.errors, :status => :unprocessable_entity }
      end
    end
  end

  # DELETE /roles/1
  # DELETE /roles/1.xml
  def destroy
    @role = Role.find(params[:id])
    @role.permissions.map{|perm|  perm.delete }
    @role.destroy

    respond_to do |format|
      format.html { redirect_to(roles_url, :notice => 'The role has been deleted') }
      format.xml  { head :ok }
    end
  end
  
  # Get roles accessible by the current user 
  # Usage:
  #   Role.reflect_on_all_associations(:has_and_belongs_to_many).first.class_name => "User" 
  #   Role.reflect_on_all_associations(:has_many).first.class_name
  # @return [Array] Array of permissions for the current user
  def accessible_permissions
    @accessible_permissions = []
    controllers = Dir.new("#{RAILS_ROOT}/app/controllers").entries
    controllers = controllers.map { |controller|  controller.downcase.gsub("_controller.rb","").singularize if controller =~ /_controller/ }.compact
    models = Dir.new("#{RAILS_ROOT}/app/models").entries
    models.each do |model|
      mod = model.downcase.gsub(".rb","")
      if controllers.include?(mod)
        @accessible_permissions <<  mod.camelize.pluralize
      end
    end
    @accessible_permissions
  end
  
  private
  
    # Save permissions all permissions for a single role
    # First deletes all permissions for the role, then loops through the input and saves new permissions
    #
    # @param role Role To reset permisisons on
    # @param role_ids A list of permissions to apply to the role
    def save_permissions(role,role_ids)
      role.permissions.map{|perm|  perm.delete }
      role_ids.each do |permission|  
        p = Permission.new(JSON.parse(permission))
        (p.class.reflect_on_all_associations(:has_many) & p.class.reflect_on_all_associations(:has_and_belongs_to_many)).each { |association|
          role.permissions << Permission.new(
            :role_id => role.id,
            :controller => association.class_name.singularize,
            :ability => p.ability
          )
        }
        role.permissions << p
      end
    end
end
